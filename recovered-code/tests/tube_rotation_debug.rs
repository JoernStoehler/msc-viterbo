//! Debug tests for tube algorithm rotation computation.
//!
//! This module provides detailed instrumentation of the tube algorithm to debug
//! rotation computation issues on the skewed simplex.
//!
//! Created for issue: Debug tube algorithm rotation computation

use crate::affine::{AffineFunc, AffineMap2D};
use crate::polygon::Polygon2D;
use crate::polytope::{FlowDir, PolytopeData, TwoFaceData};
use crate::tube::{
    compute_flow_map, extend_tube, flow_allows_crossing, get_extensions, solve_closed_tube,
    ExtensionResult, Tube,
};
use rust_viterbo_geom::{symplectic_form, Matrix2f, PolytopeHRep, SymplecticVector, Vector2f};
use std::collections::BinaryHeap;
use std::fs::File;
use std::io::Write;

use super::fixtures::skewed_simplex_4d;

/// Comprehensive debug output structure
struct DebugOutput {
    lines: Vec<String>,
}

impl DebugOutput {
    fn new() -> Self {
        Self { lines: Vec::new() }
    }

    fn log(&mut self, s: &str) {
        eprintln!("{}", s);
        self.lines.push(s.to_string());
    }

    fn logf(&mut self, s: String) {
        eprintln!("{}", s);
        self.lines.push(s);
    }

    fn section(&mut self, title: &str) {
        self.log("");
        self.logf(format!("## {}", title));
        self.log("");
    }

    fn write_to_file(&self, path: &str) -> std::io::Result<()> {
        let mut file = File::create(path)?;
        writeln!(file, "# Tube Algorithm Rotation Debug Report")?;
        writeln!(file)?;
        writeln!(
            file,
            "Generated by `tube_rotation_debug.rs` debug test on skewed simplex."
        )?;
        writeln!(file)?;
        for line in &self.lines {
            writeln!(file, "{}", line)?;
        }
        Ok(())
    }
}

/// Check 1: Print rotation values for each 2-face
fn check_rotation_values(data: &PolytopeData, out: &mut DebugOutput) {
    out.section("1. Rotation Values for Each 2-Face");

    let mut min_rot = f64::INFINITY;
    let mut max_rot = f64::NEG_INFINITY;
    let mut nan_count = 0;
    let mut inf_count = 0;
    let mut large_count = 0; // |rho| > 5

    out.logf(format!("Total non-Lagrangian 2-faces: {}", data.two_faces.len()));
    out.log("");
    out.log("| Face | (i,j) | omega | rho | flow_dir | polygon_verts | status |");
    out.log("|------|-------|-------|-----|----------|---------------|--------|");

    for (idx, face) in data.two_faces.iter().enumerate() {
        let omega = symplectic_form(data.hrep.normals[face.i], data.hrep.normals[face.j]);
        let rho = face.rotation;

        let status = if rho.is_nan() {
            nan_count += 1;
            "NaN"
        } else if rho.is_infinite() {
            inf_count += 1;
            "Inf"
        } else if rho.abs() > 5.0 {
            large_count += 1;
            ">5"
        } else {
            min_rot = min_rot.min(rho);
            max_rot = max_rot.max(rho);
            "OK"
        };

        out.logf(format!(
            "| {} | ({},{}) | {:.6} | {:.6} | {:?} | {} | {} |",
            idx,
            face.i,
            face.j,
            omega,
            rho,
            face.flow_direction,
            face.polygon.vertices.len(),
            status
        ));
    }

    out.log("");
    out.logf(format!("### Summary"));
    out.logf(format!("- NaN rotations: {}", nan_count));
    out.logf(format!("- Infinite rotations: {}", inf_count));
    out.logf(format!("- Large (|rho| > 5) rotations: {}", large_count));
    if min_rot <= max_rot {
        out.logf(format!("- Rotation range: [{:.6}, {:.6}]", min_rot, max_rot));
    } else {
        out.log("- No valid rotations found");
    }
}

/// Check 2: Print accumulated rotation during search
fn check_accumulated_rotation(data: &PolytopeData, out: &mut DebugOutput) {
    out.section("2. Accumulated Rotation During Search");

    // Track rotation statistics
    let mut rotations_at_prune: Vec<f64> = Vec::new();
    let mut rotations_at_closure: Vec<f64> = Vec::new();
    let mut max_rotation_seen = 0.0f64;
    let mut close_to_one: Vec<(Vec<usize>, f64)> = Vec::new(); // facet_seq, rotation

    let max_rotation_cutoff = 2.0; // Standard cutoff
    let eps_rot = 0.01;

    // Initialize worklist with root tubes
    let mut worklist: BinaryHeap<Tube> = BinaryHeap::new();
    for two_face in &data.two_faces {
        let tube = Tube::create_root(two_face);
        worklist.push(tube);
    }

    let mut iterations = 0;
    let max_iterations = 10000; // Prevent infinite loop

    while let Some(tube) = worklist.pop() {
        iterations += 1;
        if iterations > max_iterations {
            out.logf(format!("Stopped after {} iterations (limit reached)", iterations));
            break;
        }

        let rot = tube.rotation;
        max_rotation_seen = max_rotation_seen.max(rot);

        // Check if close to 1.0
        if (rot - 1.0).abs() < 0.05 {
            close_to_one.push((tube.facet_sequence.clone(), rot));
        }

        // Get extensions
        let extensions = get_extensions(&tube, data);

        for ext in extensions {
            match ext {
                ExtensionResult::Extension(new_tube) => {
                    // Check rotation cutoff
                    if new_tube.rotation > max_rotation_cutoff + eps_rot {
                        rotations_at_prune.push(new_tube.rotation);
                        continue;
                    }
                    worklist.push(new_tube);
                }
                ExtensionResult::Closure(closed_tube) => {
                    rotations_at_closure.push(closed_tube.rotation);
                }
            }
        }
    }

    out.logf(format!("### Search Statistics"));
    out.logf(format!("- Total iterations: {}", iterations));
    out.logf(format!("- Max rotation seen: {:.6}", max_rotation_seen));
    out.logf(format!("- Tubes pruned by rotation: {}", rotations_at_prune.len()));
    out.logf(format!("- Closure candidates found: {}", rotations_at_closure.len()));

    out.log("");
    out.log("### Rotations at Pruning");
    if rotations_at_prune.is_empty() {
        out.log("No tubes were pruned by rotation cutoff.");
    } else {
        let min_prune = rotations_at_prune.iter().cloned().fold(f64::INFINITY, f64::min);
        let max_prune = rotations_at_prune
            .iter()
            .cloned()
            .fold(f64::NEG_INFINITY, f64::max);
        out.logf(format!("- Range: [{:.6}, {:.6}]", min_prune, max_prune));

        // Histogram
        let mut hist = vec![0; 10];
        for &r in &rotations_at_prune {
            let bucket = ((r - 2.0) * 10.0).floor() as usize;
            if bucket < 10 {
                hist[bucket] += 1;
            }
        }
        out.log("- Distribution (rotation - 2.0):");
        for (i, count) in hist.iter().enumerate() {
            if *count > 0 {
                out.logf(format!(
                    "  [{:.1}, {:.1}): {}",
                    2.0 + i as f64 * 0.1,
                    2.0 + (i + 1) as f64 * 0.1,
                    count
                ));
            }
        }
    }

    out.log("");
    out.log("### Rotations at Closure");
    if rotations_at_closure.is_empty() {
        out.log("No closure candidates found.");
    } else {
        let min_closure = rotations_at_closure
            .iter()
            .cloned()
            .fold(f64::INFINITY, f64::min);
        let max_closure = rotations_at_closure
            .iter()
            .cloned()
            .fold(f64::NEG_INFINITY, f64::max);
        out.logf(format!("- Range: [{:.6}, {:.6}]", min_closure, max_closure));

        out.log("- First 10 closure rotations:");
        for (i, r) in rotations_at_closure.iter().take(10).enumerate() {
            out.logf(format!("  {}: {:.6}", i, r));
        }
    }

    out.log("");
    out.log("### Tubes Close to Rotation = 1.0");
    if close_to_one.is_empty() {
        out.log("No tubes with rotation close to 1.0 found.");
    } else {
        out.logf(format!("Found {} tubes with rotation in [0.95, 1.05]:", close_to_one.len()));
        for (seq, rot) in close_to_one.iter().take(10) {
            out.logf(format!("  seq={:?}, rot={:.6}", seq, rot));
        }
    }
}

/// Check 3: Check flow map coefficients
fn check_flow_map_coefficients(data: &PolytopeData, out: &mut DebugOutput) {
    out.section("3. Flow Map Coefficients");

    let mut large_coeffs: Vec<(usize, usize, usize, usize, f64)> = Vec::new(); // entry_i, entry_j, exit_i, exit_j, max_coeff
    let mut small_coeffs: Vec<(usize, usize, usize, usize, f64)> = Vec::new();
    let mut all_max_coeffs: Vec<f64> = Vec::new();

    // For each 2-face, compute flow maps to adjacent 2-faces
    for entry_face in &data.two_faces {
        let (_, current_facet) = match entry_face.flow_direction {
            FlowDir::ItoJ => (entry_face.i, entry_face.j),
            FlowDir::JtoI => (entry_face.j, entry_face.i),
        };

        // Find adjacent 2-faces
        let adjacent = data.faces_adjacent_to(current_facet);
        for exit_face in adjacent {
            let next_facet = if exit_face.i == current_facet {
                exit_face.j
            } else {
                exit_face.i
            };

            if !flow_allows_crossing(current_facet, next_facet, exit_face.flow_direction) {
                continue;
            }

            // Compute flow map
            let flow_data = compute_flow_map(entry_face, exit_face, current_facet, next_facet, data);

            // Check coefficient magnitudes
            let m = &flow_data.map.linear;
            let coeffs = [m[(0, 0)], m[(0, 1)], m[(1, 0)], m[(1, 1)]];
            let offset_coeffs = [flow_data.map.offset.x, flow_data.map.offset.y];
            let time_coeffs = [
                flow_data.time_func.gradient.x,
                flow_data.time_func.gradient.y,
                flow_data.time_func.constant,
            ];

            let max_coeff = coeffs
                .iter()
                .chain(offset_coeffs.iter())
                .chain(time_coeffs.iter())
                .map(|x| x.abs())
                .fold(0.0f64, f64::max);

            let min_nonzero = coeffs
                .iter()
                .chain(offset_coeffs.iter())
                .chain(time_coeffs.iter())
                .filter(|x| x.abs() > 1e-15)
                .map(|x| x.abs())
                .fold(f64::INFINITY, f64::min);

            all_max_coeffs.push(max_coeff);

            if max_coeff > 1e6 {
                large_coeffs.push((entry_face.i, entry_face.j, exit_face.i, exit_face.j, max_coeff));
            }
            if min_nonzero < 1e-10 && min_nonzero > 0.0 {
                small_coeffs.push((
                    entry_face.i,
                    entry_face.j,
                    exit_face.i,
                    exit_face.j,
                    min_nonzero,
                ));
            }
        }
    }

    out.logf(format!("Total flow maps computed: {}", all_max_coeffs.len()));

    if !all_max_coeffs.is_empty() {
        let global_max = all_max_coeffs.iter().cloned().fold(0.0f64, f64::max);
        let global_min = all_max_coeffs.iter().cloned().fold(f64::INFINITY, f64::min);
        out.logf(format!(
            "Max coefficient range: [{:.6e}, {:.6e}]",
            global_min, global_max
        ));
    }

    out.log("");
    out.log("### Large Coefficients (>1e6)");
    if large_coeffs.is_empty() {
        out.log("No flow maps with coefficients > 1e6.");
    } else {
        out.logf(format!("Found {} flow maps with large coefficients:", large_coeffs.len()));
        for (ei, ej, xi, xj, max_c) in large_coeffs.iter().take(10) {
            out.logf(format!(
                "  ({},{})->({},{}): max_coeff={:.6e}",
                ei, ej, xi, xj, max_c
            ));
        }
    }

    out.log("");
    out.log("### Small Coefficients (<1e-10)");
    if small_coeffs.is_empty() {
        out.log("No flow maps with very small non-zero coefficients.");
    } else {
        out.logf(format!(
            "Found {} flow maps with small coefficients:",
            small_coeffs.len()
        ));
        for (ei, ej, xi, xj, min_c) in small_coeffs.iter().take(10) {
            out.logf(format!(
                "  ({},{})->({},{}): min_nonzero={:.6e}",
                ei, ej, xi, xj, min_c
            ));
        }
    }

    // Print a few example flow maps in detail
    out.log("");
    out.log("### Sample Flow Maps (first 3)");
    let mut count = 0;
    'outer: for entry_face in &data.two_faces {
        let (_, current_facet) = match entry_face.flow_direction {
            FlowDir::ItoJ => (entry_face.i, entry_face.j),
            FlowDir::JtoI => (entry_face.j, entry_face.i),
        };

        let adjacent = data.faces_adjacent_to(current_facet);
        for exit_face in adjacent {
            let next_facet = if exit_face.i == current_facet {
                exit_face.j
            } else {
                exit_face.i
            };

            if !flow_allows_crossing(current_facet, next_facet, exit_face.flow_direction) {
                continue;
            }

            let flow_data = compute_flow_map(entry_face, exit_face, current_facet, next_facet, data);

            out.logf(format!(
                "Flow map ({},{})->({},{}):",
                entry_face.i, entry_face.j, exit_face.i, exit_face.j
            ));
            out.logf(format!("  Linear: [{:.6}, {:.6}; {:.6}, {:.6}]",
                flow_data.map.linear[(0, 0)],
                flow_data.map.linear[(0, 1)],
                flow_data.map.linear[(1, 0)],
                flow_data.map.linear[(1, 1)]
            ));
            out.logf(format!(
                "  Offset: ({:.6}, {:.6})",
                flow_data.map.offset.x, flow_data.map.offset.y
            ));
            out.logf(format!(
                "  Time func: ({:.6}, {:.6}) * p + {:.6}",
                flow_data.time_func.gradient.x,
                flow_data.time_func.gradient.y,
                flow_data.time_func.constant
            ));
            out.logf(format!(
                "  Determinant: {:.6}",
                flow_data.map.linear.determinant()
            ));

            count += 1;
            if count >= 3 {
                break 'outer;
            }
        }
    }
}

/// Check 4: Check fixed point computation
fn check_fixed_point_computation(data: &PolytopeData, out: &mut DebugOutput) {
    out.section("4. Fixed Point Computation");

    // Run the search to find closure candidates and check their fixed points
    let mut worklist: BinaryHeap<Tube> = BinaryHeap::new();
    for two_face in &data.two_faces {
        let tube = Tube::create_root(two_face);
        worklist.push(tube);
    }

    let mut closure_candidates: Vec<Tube> = Vec::new();
    let mut iterations = 0;
    let max_iterations = 5000;
    let max_rotation_cutoff = 2.0;
    let eps_rot = 0.01;

    while let Some(tube) = worklist.pop() {
        iterations += 1;
        if iterations > max_iterations {
            break;
        }

        let extensions = get_extensions(&tube, data);

        for ext in extensions {
            match ext {
                ExtensionResult::Extension(new_tube) => {
                    if new_tube.rotation > max_rotation_cutoff + eps_rot {
                        continue;
                    }
                    worklist.push(new_tube);
                }
                ExtensionResult::Closure(closed_tube) => {
                    closure_candidates.push(closed_tube);
                }
            }
        }
    }

    out.logf(format!("Total closure candidates: {}", closure_candidates.len()));

    if closure_candidates.is_empty() {
        out.log("No closure candidates found. Cannot check fixed points.");
        return;
    }

    // Analyze fixed points
    let mut fp_inside = 0;
    let mut fp_outside = 0;
    let mut fp_none = 0;
    let mut fp_examples: Vec<String> = Vec::new();

    for (i, tube) in closure_candidates.iter().enumerate() {
        let fp = tube.flow_map.fixed_point();

        let status = match fp {
            None => {
                fp_none += 1;
                let det = (Matrix2f::identity() - tube.flow_map.linear).determinant();
                format!(
                    "  #{}: seq={:?}, NO FIXED POINT (I-A det={:.6e})",
                    i, tube.facet_sequence, det
                )
            }
            Some(p) => {
                let inside = tube.p_start.contains(p);
                if inside {
                    fp_inside += 1;
                    format!(
                        "  #{}: seq={:?}, INSIDE: fp=({:.6}, {:.6})",
                        i, tube.facet_sequence, p.x, p.y
                    )
                } else {
                    fp_outside += 1;
                    format!(
                        "  #{}: seq={:?}, OUTSIDE: fp=({:.6}, {:.6})",
                        i, tube.facet_sequence, p.x, p.y
                    )
                }
            }
        };

        if fp_examples.len() < 20 {
            fp_examples.push(status);
        }
    }

    out.log("");
    out.log("### Fixed Point Summary");
    out.logf(format!("- Fixed point inside p_start: {}", fp_inside));
    out.logf(format!("- Fixed point outside p_start: {}", fp_outside));
    out.logf(format!("- No fixed point (singular I-A): {}", fp_none));

    out.log("");
    out.log("### First 20 Closure Candidates");
    for ex in &fp_examples {
        out.log(ex);
    }

    // For candidates with inside fixed points, try to solve
    out.log("");
    out.log("### Attempting to Solve Closures with Inside Fixed Points");
    let mut solved_count = 0;
    for tube in &closure_candidates {
        if let Some(fp) = tube.flow_map.fixed_point() {
            if tube.p_start.contains(fp) {
                if let Some((action, witness)) = solve_closed_tube(tube, data) {
                    out.logf(format!(
                        "  SOLVED: seq={:?}, action={:.6}, times={:?}",
                        tube.facet_sequence, action, witness.segment_times
                    ));
                    solved_count += 1;
                    if solved_count >= 5 {
                        break;
                    }
                }
            }
        }
    }
    if solved_count == 0 {
        out.log("  No closures could be solved.");
    }
}

/// Check 5: Ablate rotation computation
fn check_ablated_rotation(data: &PolytopeData, out: &mut DebugOutput) {
    out.section("5. Ablation: Zero Rotation for All 2-Faces");

    out.log("Testing what happens if we ignore rotation entirely...");
    out.log("");

    // Create modified data with zero rotations (conceptually)
    // We can't modify data, but we can run the search without rotation cutoffs

    let mut worklist: BinaryHeap<Tube> = BinaryHeap::new();
    for two_face in &data.two_faces {
        let tube = Tube::create_root(two_face);
        worklist.push(tube);
    }

    let mut closure_candidates: Vec<Tube> = Vec::new();
    let mut iterations = 0;
    let max_iterations = 10000;
    // No rotation cutoff - explore more

    while let Some(tube) = worklist.pop() {
        iterations += 1;
        if iterations > max_iterations {
            out.logf(format!("Stopped after {} iterations (no rotation cutoff)", iterations));
            break;
        }

        // Limit search depth instead
        if tube.facet_sequence.len() > 15 {
            continue;
        }

        let extensions = get_extensions(&tube, data);

        for ext in extensions {
            match ext {
                ExtensionResult::Extension(new_tube) => {
                    worklist.push(new_tube);
                }
                ExtensionResult::Closure(closed_tube) => {
                    closure_candidates.push(closed_tube);
                }
            }
        }
    }

    out.logf(format!("Closure candidates (no rotation cutoff): {}", closure_candidates.len()));

    // Try to solve all closures
    let mut solved = Vec::new();
    for tube in &closure_candidates {
        if let Some((action, witness)) = solve_closed_tube(tube, data) {
            solved.push((action, tube.facet_sequence.clone(), tube.rotation, witness));
        }
    }

    out.logf(format!("Successfully solved closures: {}", solved.len()));

    if !solved.is_empty() {
        // Sort by action
        solved.sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap_or(std::cmp::Ordering::Equal));

        out.log("");
        out.log("### Solved Orbits (sorted by action)");
        for (i, (action, seq, rot, witness)) in solved.iter().take(10).enumerate() {
            out.logf(format!(
                "  {}: action={:.6}, rotation={:.6}, seq={:?}",
                i, action, rot, seq
            ));
            out.logf(format!("      times={:?}", witness.segment_times));
        }

        let min_action = solved.first().unwrap().0;
        out.log("");
        out.logf(format!("**Minimum action found: {:.6}**", min_action));
    } else {
        out.log("No orbits found even without rotation cutoff.");
        out.log("This indicates the issue is NOT with rotation computation.");
        out.log("Possible issues: flow maps, fixed point computation, or polygon intersection.");
    }
}

/// Additional check: Detailed polygon analysis
fn check_polygon_geometry(data: &PolytopeData, out: &mut DebugOutput) {
    out.section("6. Polygon Geometry Analysis");

    out.log("Analyzing 2-face polygon properties...");
    out.log("");
    out.log("| Face | Vertices | Area | Diameter | Status |");
    out.log("|------|----------|------|----------|--------|");

    for (idx, face) in data.two_faces.iter().enumerate() {
        let verts = &face.polygon.vertices;
        let n = verts.len();

        if n < 3 {
            out.logf(format!("| {} | {} | N/A | N/A | DEGENERATE |", idx, n));
            continue;
        }

        // Compute signed area
        let mut area = 0.0;
        for i in 0..n {
            let v1 = verts[i];
            let v2 = verts[(i + 1) % n];
            area += v1.x * v2.y - v2.x * v1.y;
        }
        area = area.abs() / 2.0;

        // Compute diameter
        let mut max_dist: f64 = 0.0;
        for i in 0..n {
            for j in (i + 1)..n {
                let d = (verts[i] - verts[j]).norm();
                max_dist = max_dist.max(d);
            }
        }

        let status = if area < 1e-10 {
            "TINY"
        } else if area > 100.0 {
            "LARGE"
        } else {
            "OK"
        };

        out.logf(format!(
            "| {} | {} | {:.6e} | {:.6} | {} |",
            idx, n, area, max_dist, status
        ));
    }
}

/// Check transition matrix properties
fn check_transition_matrices(data: &PolytopeData, out: &mut DebugOutput) {
    out.section("7. Transition Matrix Properties");

    out.log("Checking transition matrices (psi_F) for each 2-face...");
    out.log("");

    use rust_viterbo_geom::{classify_sp2, transition_matrix, Sp2Class};

    out.log("| Face | (i,j) | Trace | Det | Class | Rotation |");
    out.log("|------|-------|-------|-----|-------|----------|");

    for (idx, face) in data.two_faces.iter().enumerate() {
        let (exit_n, entry_n) = match face.flow_direction {
            FlowDir::ItoJ => (data.hrep.normals[face.i], data.hrep.normals[face.j]),
            FlowDir::JtoI => (data.hrep.normals[face.j], data.hrep.normals[face.i]),
        };

        let psi = transition_matrix(exit_n, entry_n);
        let tr = psi.trace();
        let det = psi.determinant();
        let class = classify_sp2(psi);

        out.logf(format!(
            "| {} | ({},{}) | {:.6} | {:.6} | {:?} | {:.6} |",
            idx, face.i, face.j, tr, det, class, face.rotation
        ));
    }

    // Check for any non-positive-elliptic
    let non_elliptic: Vec<_> = data
        .two_faces
        .iter()
        .enumerate()
        .filter(|(_, f)| {
            let (exit_n, entry_n) = match f.flow_direction {
                FlowDir::ItoJ => (data.hrep.normals[f.i], data.hrep.normals[f.j]),
                FlowDir::JtoI => (data.hrep.normals[f.j], data.hrep.normals[f.i]),
            };
            let psi = transition_matrix(exit_n, entry_n);
            classify_sp2(psi) != Sp2Class::PositiveElliptic
        })
        .collect();

    out.log("");
    if non_elliptic.is_empty() {
        out.log("All transition matrices are positive elliptic (expected for non-Lagrangian 2-faces).");
    } else {
        out.logf(format!(
            "WARNING: {} 2-faces have non-positive-elliptic transition matrices!",
            non_elliptic.len()
        ));
        for (idx, face) in non_elliptic {
            out.logf(format!("  Face {}: ({},{})", idx, face.i, face.j));
        }
    }
}

/// Main debug test
#[test]
fn debug_tube_rotation_comprehensive() {
    let mut out = DebugOutput::new();

    out.log("# Tube Algorithm Rotation Debug");
    out.log("");
    out.log("Skewed 4-Simplex Analysis");

    // Load skewed simplex
    let hrep = skewed_simplex_4d();
    out.section("Polytope Info");
    out.logf(format!("Polytope: Skewed 4-Simplex"));
    out.logf(format!("Facets: {}", hrep.normals.len()));
    out.logf(format!("Heights: {:?}", hrep.heights));

    out.log("");
    out.log("Normals:");
    for (i, n) in hrep.normals.iter().enumerate() {
        out.logf(format!(
            "  n[{}] = ({:.6}, {:.6}, {:.6}, {:.6})",
            i, n.x, n.y, n.z, n.w
        ));
    }

    // Build PolytopeData
    let data = PolytopeData::new(hrep);
    out.logf(format!(
        "\nNon-Lagrangian 2-faces detected: {}",
        data.two_faces.len()
    ));

    // Run all checks
    check_rotation_values(&data, &mut out);
    check_transition_matrices(&data, &mut out);
    check_polygon_geometry(&data, &mut out);
    check_flow_map_coefficients(&data, &mut out);
    check_accumulated_rotation(&data, &mut out);
    check_fixed_point_computation(&data, &mut out);
    check_ablated_rotation(&data, &mut out);

    // Summary
    out.section("Summary and Conclusions");
    out.log("Review the above sections to identify the root cause of tube algorithm issues.");
    out.log("");
    out.log("Key questions answered:");
    out.log("1. Are rotation values valid (no NaN/Inf, in (0, 0.5))?");
    out.log("2. Does rotation ever accumulate close to 1.0?");
    out.log("3. Are flow map coefficients numerically stable?");
    out.log("4. Are fixed points being found and are they inside polygons?");
    out.log("5. Does disabling rotation cutoffs reveal hidden orbits?");

    // Write to file
    let output_path = "/workspaces/msc-viterbo/scratch/tube-rotation-debug.md";
    match out.write_to_file(output_path) {
        Ok(()) => {
            eprintln!("\nDebug report written to: {}", output_path);
        }
        Err(e) => {
            eprintln!("\nFailed to write debug report: {}", e);
        }
    }
}

/// Simplified test that doesn't require chrono
#[test]
fn debug_tube_rotation_simple() {
    eprintln!("=== Tube Rotation Debug (Simple Version) ===");
    eprintln!();

    let hrep = skewed_simplex_4d();
    eprintln!("Skewed simplex: {} facets", hrep.normals.len());

    let data = PolytopeData::new(hrep.clone());
    eprintln!("Non-Lagrangian 2-faces: {}", data.two_faces.len());

    // Check 1: Rotation values
    eprintln!("\n--- Check 1: Rotation Values ---");
    let mut nan_count = 0;
    let mut inf_count = 0;
    for (i, face) in data.two_faces.iter().enumerate() {
        let rho = face.rotation;
        if rho.is_nan() {
            nan_count += 1;
            eprintln!("  Face {}: NaN rotation!", i);
        } else if rho.is_infinite() {
            inf_count += 1;
            eprintln!("  Face {}: Infinite rotation!", i);
        } else {
            eprintln!("  Face {} ({},{}): rho = {:.6}", i, face.i, face.j, rho);
        }
    }
    eprintln!("NaN: {}, Inf: {}", nan_count, inf_count);

    // Check 2: Search
    eprintln!("\n--- Check 2: Search Statistics ---");
    let mut worklist: BinaryHeap<Tube> = BinaryHeap::new();
    for two_face in &data.two_faces {
        worklist.push(Tube::create_root(two_face));
    }

    let mut iterations = 0;
    let mut closures = 0;
    let mut pruned = 0;
    let max_rot_cutoff = 2.01;

    while let Some(tube) = worklist.pop() {
        iterations += 1;
        if iterations > 5000 {
            break;
        }

        for ext in get_extensions(&tube, &data) {
            match ext {
                ExtensionResult::Extension(new_tube) => {
                    if new_tube.rotation > max_rot_cutoff {
                        pruned += 1;
                    } else {
                        worklist.push(new_tube);
                    }
                }
                ExtensionResult::Closure(closed_tube) => {
                    closures += 1;
                    eprintln!(
                        "  Closure {}: seq={:?}, rot={:.4}",
                        closures, closed_tube.facet_sequence, closed_tube.rotation
                    );

                    // Try to solve
                    if let Some((action, _)) = solve_closed_tube(&closed_tube, &data) {
                        eprintln!("    -> SOLVED! action={:.6}", action);
                    } else {
                        // Check why it failed
                        match closed_tube.flow_map.fixed_point() {
                            None => eprintln!("    -> No fixed point"),
                            Some(fp) => {
                                if !closed_tube.p_start.contains(fp) {
                                    eprintln!("    -> Fixed point outside: ({:.4}, {:.4})", fp.x, fp.y);
                                } else {
                                    eprintln!("    -> Unknown failure with fp inside");
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    eprintln!("\nIterations: {}", iterations);
    eprintln!("Closures found: {}", closures);
    eprintln!("Pruned by rotation: {}", pruned);

    // Check 3: Flow map sample
    eprintln!("\n--- Check 3: Sample Flow Map ---");
    if let Some(face) = data.two_faces.first() {
        let (_, curr) = match face.flow_direction {
            FlowDir::ItoJ => (face.i, face.j),
            FlowDir::JtoI => (face.j, face.i),
        };
        if let Some(adj) = data.faces_adjacent_to(curr).first() {
            let next = if adj.i == curr { adj.j } else { adj.i };
            if flow_allows_crossing(curr, next, adj.flow_direction) {
                let flow_data = compute_flow_map(face, adj, curr, next, &data);
                eprintln!("Flow map ({},{})->({},{}):", face.i, face.j, adj.i, adj.j);
                let m = &flow_data.map.linear;
                eprintln!("  Linear: [[{:.4}, {:.4}], [{:.4}, {:.4}]]",
                    m[(0,0)], m[(0,1)], m[(1,0)], m[(1,1)]);
                eprintln!("  Offset: ({:.4}, {:.4})", flow_data.map.offset.x, flow_data.map.offset.y);
                eprintln!("  Det: {:.6}", m.determinant());
            }
        }
    }
}
