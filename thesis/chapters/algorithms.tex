% !TeX root = ../main.tex

This chapter describes the algorithms developed in the literature and as part of this thesis in order to do symplectic geometry on polytopes, and in particular to compute the Ekeland--Hofer--Zehnder capacity \(\cEHZ(K)\) and systolic ratio \(\sys(K)\) for polytopes \(K \subset \R^4\).
We start by briefly describing how we algorithmically represent basic symplectic data about polytopes.
Then, we present the three main algorithmic approaches to computing \(\cEHZ(K)\) for polytopes \(K\) from the literature:
\begin{itemize}
  \item the HK2017 algorithm, which we specialize from dimension \(2n\) to dimension \(4\),
  \item the CH2021 algorithm, which assumes a generic property about the polytope \(K\), and
  \item the Minkowski Billiard algorithm, partially discussed in HK2024, which only applies to lagrangian products of 2-dim polygons.
\end{itemize}
We improve upon the literature algorithms, mainly CH2021, to cover all edge cases and achieve sufficient numerical stability and performance to investigate some polytope families of interest for Viterbo's conjecture.
Finally, we present empirical results from benchmarking the different algorithms using our own implementations, and discuss practical considerations for running large-scale experiments to probe Viterbo's conjecture.

The main subroutine of interest is the capacity computation, the rest is rather straightforward, so we focus on that.
The input to this subroutine is in general a convex polytope \(K \subset \R^4\) in some simple representation, and the output is an approximative statement about \(\cEHZ(K)\) together with a certificate that allows to verify the statement. We mostly discuss the following approximative statements:
\begin{itemize}
  \item assuming infinite precision in representing reals/rationals, compute the exact value of \(\cEHZ(K)\),
  \item under finite precision, compute a single output value, such that stochastically the output has good quantiative error bounds.
  \item under finite precision, compute an interval output, such that stochastically the interval contains the true value with high probability.
\end{itemize}
We understand the problem as stochastically wrt a random input polytope with an ``appropriate'' probability distribution, e.g. for massive data experiments we may sample random polytopes from some family.

It's not that common that this kind of detailed error analysis is done. We have two reasons to put in the effort, and readers may skip the numerical sections unless interested in verifying the results or learning from the analysis methodology. The first reason is that we want to target enumerative proofs using our library, in which case we need proven statements about the algorithm's actual behavior, without waving away numerical rounding errors that impact threshold control flow or that blow up in other ways.
The second reason is that we want to be able to use our library of algorithm implementations to form conjectures, and avoid misleading signals from erroneous outputs that we misinterpret as either too imprecise (leading to fewer interesting conjectures) or too accurate (leading to more false conjectures).
The numerical analysis does not really tell us much of interest about the symplectic geometry, perhaps some extra motivation to look into degeneracies and local behavior of \(\cEHZ\) in the polytope space, but mostly it is just a necessary engineering step to get reliable outputs from the algorithms.

\section{Representation of Polytopes and Basic Symplectic Data}\label{sec:algo-representations}

\paragraph{Half-space Representation of Polytopes}
The main representation of a convex polytope \(K \subset \R^4\) used in the algorithms is via its unique irredundant half-space representation (H-rep):
\begin{description}
  \item[Facet count] \(F \in \Z_{\ge 5}\) is the number of facets \((F_i)_{i=1}^F\) of \(K\). At least 5 facets are needed to enclose a bounded volume in \(\R^4\).
  \item[Facet normals] For each facet we have an outward normal vector \(n_i \in \R^4\) with \(\norm{n_i} = 1\).
  \item[Facet heights] For each facet we have a support number \(h_i \in \R_{>0}\) such that the origin is contained in the interior of \(K\).
  \item[Polytope definition] The polytope is then defined as the intersection of the half-spaces:
    \[
      K = \bigcap_{i=1}^F \{ z \in \R^4 : \inner{n_i}{z} \le h_i \}.
    \]
  \item[Constraints] We have to assume boundedness and irredundancy as extra constraint, i.e. not every normal and height set defines a bounded polytope irredundantly.
\end{description}

\paragraph{Vertex Representation of Polytopes}
We sometimes convert to the vertex/extreme point representation (V-rep) as needed, using off-the-shelf algorithms.
\begin{description}
  \item[Vertex count] \(V \in \Z_{\ge 5}\) is the number of vertices of \(K\). No simple correspondence to \(F\) exists in general.
  \item[Vertices] The vertices are points \(v_j \in \R^4\) for \(j \in \{1, \ldots, V\}\) such that
    \[
      K = \conv\{ v_j : j = 1, \ldots, V \}.
    \]
  \item[Constraints] We have to assume that \(0 \in \interior(K)\) as an extra constraint, as well as again irredundancy, i.e. no vertex can be removed without changing \(K\).
\end{description}

\paragraph{Polytope Faces}
We also need to represent the skeleton of the polytope for some algorithms.
Any of the non-empty \(k\)-Faces of \(K\) for \(k \in \{0,1,2,3\}\) can be represented as a lower-dimensional convex bounded non-empty polytope in a \(k\)-dimensional affine subspace of \(\R^4\) that is the intersection of several hyperplanes defining facets of \(K\).
Each \(k\)-Face \(F\) has a unique representation using
\begin{description}
  \item[Half-space Hyperplane Set] The maximal index set \(I \subset \{1, \ldots, F\}\) of the hyperplanes whose intersection defines the affine subspace containing \(F\). We picked the unique maximum instead of an arbitrary minimal set, to allow us to match data to the \(\ge k+1\)-faces containing \(F\) easily.
  \item[Half-space Inequalities] The maximal index set \(J \subset \{1, \ldots, F\}\) with \(I \subset J\) of sharp half-space inequalities that define \(F\). We picked the sharp inequalities to easily talk about the \(\le k-1\)-faces contained in \(F\). Unsharp inequalities are redundant not just for \(F\) but all sub-faces, and so we omit them.
    \[
      F = \bigcap_{i \in J} \{ z \in \R^4 : \inner{n_i}{z} \le h_i \} \subset \bigcap_{i \in I} \{ z \in \R^4 : \inner{n_i}{z} = h_i \} \cong \R^k.
    \]
  \item[Face Vertices] Indices \(L \subset \{1, \ldots, V\}\) of the vertices of \(K\) that are the extreme points of \(F\). We have
    \[
      F = \conv\{ v_l : l \in L \}.
    \]
\end{description}

From the irredundancy of polytope representations we immediately get that 3-faces aka facets have one hyperplane, and that 2-faces have two hyperplanes. For 1-faces and 0-faces we only know the lower bound from dimension counting of three, respectively four, hyperplanes, but no upper bound. Arbitrary many facets can come together to meet in a 0-face or 1-face.
Dimension arguments also tell us that 1-faces have two inequalities and two vertices, and 0-faces have no inequalities and one vertex.

The intersection of two faces \(F,G\) is either
\begin{itemize}
  \item if \(F=G\) then \(F \cap G = F = G\),
  \item if \(F \subset G\) or \(G \subset F\) then \(F \cap G\) is the smaller face,
  \item potentially empty \(F \cap G = \emptyset\),
  \item or a third, lower-dimensional face \(F \cap G = H\), \(\dim H < \min(\dim F, \dim G)\).
\end{itemize}
This allows us to define the face lattice of \(K\) as the set of all faces ordered by inclusion, and with a precomputed intersection operation.

\paragraph{Polygonal Reeb Orbits}
We represent polygonal Reeb orbits and trajectories on the boundary of \(K\), using combinatorial and geometric data.
We decidedly don't bother designing a computational representation of non-polygonal \(W^{1,2}\) Reeb orbits, since all our search algorithms skip them anyway.

\begin{description}
  \item[Breakpoints and Breaktimes] A polygonal orbit/trajectory with \(m\) breakpoints is represented by the ordered list of breakpoints \(b_1, \ldots, b_m \in \partial K \subset \R^4\). For closed orbits we have \(b_{m+1} = b_1\) as a notational convention. The breakpoints occur at times \(0=t_1 \le \dots \le t_m < t_{m+1} = T\) along the orbit/trajectory. Note that \(t_k = t_{k+1}\) (a zero-duration segment) occurs when the orbit passes through a vertex or edge where three or more facets meet. At such points, the breakpoints coincide (\(b_k = b_{k+1}\)), and the velocity equation \(b_{k+1} = b_k + \tau_k v_k\) is vacuously satisfied. This represents a combinatorial change in which facet's Reeb vector governs subsequent flow, contributing zero to the total action.
  \item[Velocities and Facet Times] Each straight segment between breakpoints \(b_k\) and \(b_{k+1}\) has a facet Reeb vector as velocity \(v_k = \frac{2}{h_{i_k}} J n_{i_k}\) for some facet index \(i_k \in \{1, \ldots, N\}\). The velocity is constant along the segment, so \(b_{k+1} = b_k + (t_{k+1}-t_k) v_k\). The time spent on the segment is also denoted \(\tau_k = t_{k+1}-t_k\). Note that the segment may lie in lower-dimensional faces of \(K\), and thus on several facets at once, and the change in velocity at breakpoints may or may not correspond to a change in what facet the orbit is on. In the simple orbit case, we call the segment times also facet times, \(T_{i_k} = \tau_k\) with \(T_i = 0\) if facet velocity \(i\) is not used. Note that the facet may be visited on lower-dimensional faces, it's just that the velocity is never used for the Reeb orbit.
  \item[Facet Sequence] The ordered list of facet indices \(\sigma = (i_1, \ldots, i_m)\) visited by the orbit/trajectory. We only do irredundant orbits where \(i_k \neq i_{k+1}\) for all \(k\). For simple orbits, we even know that all indices are distinct, i.e. \(\sigma\) is a subset of \(\{1, \ldots, N\}\) with cyclic order.
\end{description}

The HK2017 algorithm is formulated originally as a search over valid facet time vectors \((T_i)_{i=1}^N\) and facet sequences completed to permutations \(\sigma \in S_N\).
The CH2021 algorithm is formulated as an outer search over valid facet sequences \(\sigma\), under adjacency constraints, and an inner fixed-point solver for the facet times \(T_i\) given \(\sigma\).
The Minkowski Billiard algorithm deviates in that it does not consider polygonal Reeb orbits with facet velocities, but allows convex velocity combinations on the lagrangian 2-faces, and reformulates the search space over segment lengths in one 2-dim lagrangian factor, wrt the dual norm induced by the other lagrangian factor.

If \(K = Q \times_L P\) is a lagrangian product of two bounded convex star-shaped wrt 0 sets \(P,Q \subset \R^2\), then we can represent billiard trajectories on \(\partial K\) as follows:
\begin{description}
  \item[Billiard] A number of bounces \(m\) corresponding to \(2m\) (potentially coinciding) breakpoints in \(\R^4\). The segments alternate between lagrangian factors, i.e. wlog. odd segments \([b_{2k}, b_{2k+1}] \subset \R^2_q \times \{p\}\) and even segments \([b_{2k+1}, b_{2k+2}] \subset \{q\} \times \R^2_p\).
  \item[Segment Length] The \(P^\polar\)-length of an odd segment \([b_{2k}, b_{2k+1}] \subset \R^2_q \times \{p\}\) is \(\ell^P_k = \support_P(b_{2k+1} - b_{2k})\).
\end{description}

\section{Basic Symplectic Subroutines}\label{sec:algo-subroutines}

We generally omit descriptions of the straightforward subroutine algorithms, and refer to the project codebase instead for these non-central details.
An overview of the main subroutines the library provides is given in table \ref{tab:algo-subroutines}.

\begin{table}[ht]
  \centering
  \caption{Main subroutines used in the algorithms.}
  \label{tab:algo-subroutines}
  %%% DATA: (source of truth: comments, latex is formatted below; keep source of truth updated on edits)
  % symbol(s), description, main algorithm pick, computational bottleneck
  % to_vrep\\to_hrep, convert H-rep and V-rep, cddlib, NO
  % is_valid, validate H-rep or V-rep, trivial, NO
  % face_lattice, face lattice and face representation construction, custom, NO
  % volume, volume computation, cddlib, YES
  % systolic_ratio, systolic ratio from volume and capacity, standard normalization convention per Viterbo, NO
  % is_valid, validate polygonal orbit, custom, NO
  % action, action of a polygonal orbit, custom, NO
  % capacity_hk2017, HK2017 capacity algorithm, choices from HK2017, YES
  % capacity_ch2021, CH2021 capacity algorithm, choices from CH2021, YES
  % capacity_billiard, Minkowski Billiard capacity algorithm, choices from HK2024, YES
  % capacity_sc2026, our capacity algorithm, see chapter \ref{chap:algorithms}, YES
  % ridge_graph, 2-face graph construction, custom, NO
  % new_tube, initialize a zero-step tube, custom, YES
  % extend_tube, extend by one 2-face transition, custom, YES
  % resolve_tube, find fixed point of trajectory tube, custom, YES
  % tube_extensions, enumerate 2-face extensions with a heuristic ordering, custom, YES

  %TODO table 
\end{table}

One main choice we made was to use the optimized third-party ``cddlib'' library for doing non-symplectic euklidean geometry with polytopes.

\section{Algorithm of Haim-Kislev 2017 in Dimension Four}\label{sec:algo-hk2017}

The HK2017 algorithm computes \(\cEHZ(K)\) by direct optimization over the combinatorial formula from \cref{thm-hk-combinatorial}. We present the algorithm specialized to dimension four, which simplifies the constraint structure.

\subsection{The Optimization Problem}

Let \(K \subset \R^4\) be a convex polytope with \(F\) facets, outward unit normals \((n_i)_{i=1}^F\), and heights \((h_i)_{i=1}^F\). By \cref{thm-simple-minimizer-existence}, the minimum-action closed characteristic can be taken to be simple: each facet Reeb vector appears at most once. A simple orbit is encoded by:
\begin{itemize}
  \item A subset \(S \subseteq \{1,\ldots,F\}\) of participating facets, with \(k = |S| \ge 3\).\footnote{For \(k=1\), closure \(\beta_1 n_1 = 0\) with \(\beta_1 > 0\) is impossible. For \(k=2\), closure requires \(n_1 \parallel n_2\) with opposite signs, giving \(\omega(n_1, n_2) = 0\) and hence \(Q = 0\).}
  \item A cyclic ordering \(\sigma: \{1,\ldots,k\} \to S\) specifying the order in which facets are visited.
  \item Coefficients \(\beta_i \ge 0\) for \(i \in S\), representing normalized time spent with each facet's Reeb velocity.
\end{itemize}

The constraints on \(\beta\) encode closure and normalization:
\begin{align}
  \sum_{i \in S} \beta_i h_i &= 1 \quad \text{(height/normalization constraint)}, \label{eq:hk-height} \\
  \sum_{i \in S} \beta_i n_i &= 0 \quad \text{(closure constraint, 4 equations)}. \label{eq:hk-closure}
\end{align}

The quadratic form \(Q\) is related to action by \(\cEHZ = (2 Q_{\max})^{-1}\):
\begin{equation}\label{eq:hk-quadratic}
  Q(\sigma, \beta) = \sum_{1 \le j < i \le k} \beta_{\sigma(i)} \beta_{\sigma(j)} \, \omega(n_{\sigma(i)}, n_{\sigma(j)}).
\end{equation}

\begin{theorem}[HK2017 Capacity Formula]\label{thm:hk-capacity-formula}
For a convex polytope \(K \subset \R^4\),
\[
  \cEHZ(K) = \frac{1}{2} \left[ \max_{S, \sigma, \beta} Q(\sigma, \beta) \right]^{-1},
\]
where the maximum is over all valid subsets \(S\), cyclic orderings \(\sigma\), and coefficients \(\beta\) satisfying \eqref{eq:hk-height}, \eqref{eq:hk-closure}, and \(\beta_i \ge 0\).
\end{theorem}

\begin{proof}
See \cite{HK2017} for the general \(2n\)-dimensional proof. The key steps are:
\begin{enumerate}
  \item By \cref{thm-simple-minimizer-existence}, minimizers can be taken simple.
  \item For a simple orbit with velocities \(p_{\sigma(i)} = \frac{2}{h_{\sigma(i)}} J n_{\sigma(i)}\) and time durations \(T_i\), the action is \(A = \sum_{j<i} T_{\sigma(i)} T_{\sigma(j)} \omega(n_{\sigma(i)}, n_{\sigma(j)})\).
  \item Setting \(\beta_i = T_i / (\sum_j T_j h_j)\) normalizes to constraint \eqref{eq:hk-height}.
  \item Closure \(\sum T_i p_i = 0\) becomes \eqref{eq:hk-closure} after rescaling.
  \item The formula \(\cEHZ = (2 Q_{\max})^{-1}\) follows from the scaling. \qedhere
\end{enumerate}
\end{proof}

\subsection{Structure of the Feasible Region}

For fixed \(S\) and \(\sigma\), the feasible region is
\[
  M(S) = \left\{ \beta \in \R^k : \sum_{i \in S} \beta_i h_i = 1, \; \sum_{i \in S} \beta_i n_i = 0, \; \beta_i \ge 0 \right\}.
\]
This is the intersection of an affine subspace (the equality constraints) with the non-negative orthant.

\begin{lemma}[Feasible Region Properties]\label{lem:hk-feasible}
The set \(M(S)\) is a compact convex polytope of dimension at most \(k - 5\), with equality when the 5 constraint rows (1 height + 4 closure) are linearly independent. It is bounded because \(\beta_i \ge 0\) and \(\sum \beta_i h_i = 1\) with \(h_i > 0\) imply \(\beta_i \le 1/h_i\). For \(k < 5\), the feasible region is generically empty or a single point.
\end{lemma}

The interior of \(M(S)\) is \(M^\circ(S) = \{\beta \in M(S) : \beta_i > 0 \text{ for all } i\}\). The boundary consists of faces where some \(\beta_i = 0\).

\subsection{The KKT Solver for Fixed Permutation}

For a fixed subset \(S\) and ordering \(\sigma\), the subproblem is:
\[
  \max_{\beta \in M(S)} Q(\sigma, \beta).
\]
This is a quadratic program with linear equality and inequality constraints.

\paragraph{Interior critical points.}
Ignoring the inequality constraints \(\beta_i \ge 0\), the equality-constrained problem has a unique critical point (generically) found by solving the KKT system:
\begin{equation}\label{eq:hk-kkt}
  \begin{pmatrix} H & A^\top \\ A & 0 \end{pmatrix}
  \begin{pmatrix} \beta \\ \lambda \end{pmatrix}
  = \begin{pmatrix} 0 \\ b \end{pmatrix},
\end{equation}
where \(H\) is the Hessian of \(Q\), \(A\) is the \(5 \times k\) constraint matrix (one row for height, four for closure), \(b = (1, 0, 0, 0, 0)^\top\), and \(\lambda\) are Lagrange multipliers.

\begin{lemma}[Hessian Structure]\label{lem:hk-hessian}
The Hessian \(H \in \R^{k \times k}\) of \(Q(\sigma, \cdot)\) has entries
\[
  H_{\ell m} = \begin{cases}
    \omega(n_{\sigma(\max(\ell,m))}, n_{\sigma(\min(\ell,m))}) & \text{if } \ell \neq m, \\
    0 & \text{if } \ell = m.
  \end{cases}
\]
Despite \(\omega\) being antisymmetric, \(H\) is symmetric (the index ordering absorbs the sign). The trace is zero, so \(H\) is generically indefinite.
\end{lemma}

\paragraph{Post-hoc feasibility check.}
The KKT system \eqref{eq:hk-kkt} finds the unique critical point of \(Q\) on the affine subspace. If this critical point satisfies \(\beta_i > 0\) for all \(i\), it lies in the interior of \(M(S)\). If some \(\beta_i < 0\), the critical point is outside the feasible region, and we reject this \((S, \sigma)\) pair.

\begin{remark}[No explicit boundary search needed]
One might worry that the maximum of \(Q\) over \(M(S)\) could occur on the boundary (some \(\beta_i = 0\)) rather than at the interior critical point. However, the following lemma shows this case is handled by the search over smaller subsets.
\end{remark}

\begin{lemma}[Boundary Reduction]\label{lem:hk-boundary}
If \(\beta^* \in M(S)\) has \(\beta^*_j = 0\) for some \(j \in S\), then \(\beta^*\) corresponds to a point in \(M(S')\) where \(S' = S \setminus \{j\}\), with the same \(Q\) value.
\end{lemma}

\begin{proof}
Removing facet \(j\) from \(S\):
\begin{itemize}
  \item Constraints \eqref{eq:hk-height}--\eqref{eq:hk-closure} lose a zero term, so remain satisfied.
  \item In \(Q\), all terms involving \(\beta_j = 0\) contribute zero.
\end{itemize}
Thus \(Q(\sigma, \beta^*) = Q(\sigma', \beta')\) where \(\sigma'\) omits \(j\) and \(\beta'\) omits \(\beta_j\).
\end{proof}

\begin{corollary}[Correctness of Interior-Only Search]\label{cor:hk-interior-correct}
The global maximum \(\max_{S, \sigma, \beta} Q(\sigma, \beta)\) is achieved at a point with all \(\beta_i > 0\). Hence searching only interior critical points (via KKT) over all subsets \(S\) finds the global maximum.
\end{corollary}

\begin{proof}
The search space is finite (finitely many subsets and permutations) and each \(M(S)\) is compact, so a global maximum exists. Let \((S^*, \sigma^*, \beta^*)\) achieve it. If some \(\beta^*_j = 0\), by \cref{lem:hk-boundary}, the same \(Q\) value is achieved by \((S', \sigma', \beta')\) with \(|S'| < |S^*|\). Repeating until no \(\beta_i = 0\) (terminating since \(|S| \ge 3\)) gives a strictly interior maximizer.
\end{proof}

\subsection{Algorithm Summary}

\begin{enumerate}
  \item \textbf{Enumerate subsets}: For each non-empty \(S \subseteq \{1, \ldots, F\}\) with \(|S| \ge 3\):
  \item \textbf{Enumerate orderings}: For each cyclic ordering \(\sigma\) of \(S\):
  \begin{enumerate}
    \item Solve the KKT system \eqref{eq:hk-kkt} for \(\beta\).
    \item If all \(\beta_i > 0\) and constraints are satisfied, compute \(Q(\sigma, \beta)\).
    \item Track the maximum \(Q\) found.
  \end{enumerate}
  \item \textbf{Return}: \(\cEHZ(K) = (2 Q_{\max})^{-1}\).
\end{enumerate}

\paragraph{Complexity.}
The naive algorithm enumerates \(O(F!)\) permutations. For polytopes with sparse facet transition graphs, many permutations can be pruned by checking geometric adjacency (a valid orbit must transition between facets that share a 2-face with compatible Reeb flow direction). For non-Lagrangian polytopes, the Chaidez--Hutchings bound \(\rho \le 2\) further limits the search to orbits with bounded combinatorial rotation number \cite{CH2021}.

\paragraph{Numerical considerations.}
The KKT system is solved via LU decomposition. Tolerances are needed for:
\begin{itemize}
  \item Constraint satisfaction: \(|\sum \beta_i h_i - 1| < \epsilon\), \(\|\sum \beta_i n_i\| < \epsilon\).
  \item Positivity check: \(\beta_i > -\epsilon\) (allowing small numerical violations).
  \item Singularity detection: the KKT matrix may be singular for degenerate polytopes.
\end{itemize}

\subsection{Comparison with Other Algorithms}

The HK2017 algorithm has the advantage of being self-contained: it requires only the H-rep data \((n_i, h_i)\) and linear algebra. Its main disadvantages are:
\begin{itemize}
  \item \textbf{Factorial complexity}: Even with pruning, the permutation search grows rapidly with \(F\).
  \item \textbf{No early termination}: Unlike the tube-based algorithms (\cref{sec:algo-ours}), there is no natural way to obtain upper bounds during the search for pruning.
  \item \textbf{Indirect geometric certificate}: The output \((\sigma, \beta)\) determines a trajectory, but reconstructing explicit breakpoints on \(\partial K\) requires additional computation (solving for positions from velocities and times).
\end{itemize}

For polytopes with few facets (\(F \le 10\)), HK2017 is practical and serves as a reference for validating other algorithms. For larger polytopes, the tube-based approach of \cref{sec:algo-ours} is preferred.

\section{Algorithm of Chadez--Hutchings 2021}\label{sec:algo-ch2021}
% TODO: Present the second algorithm for capacity computation from the literature.

\section{Algorithm of Minkowski Billiards}\label{sec:algo-billiards}

% =============================================================================
% DESIGN NOTES (2026-01-29 discussion between JÃ¶rn and Claude)
% =============================================================================
%
% CONTEXT: The literature (Rudolf 2022, Bezdek-Bezdek 2009) proves that for
% Lagrangian products $K_q \times K_p \subset \R^4$, the EHZ capacity equals
% the minimal length of closed Minkowski billiard trajectories with at most
% $n+1 = 3$ bounces. However, no explicit computational algorithm is given.
%
% KEY THEOREM (Rudolf 2022, Thm 1.1):
%   $c_{EHZ}(K_q \times K_p) = \min_{q \in M_{n+1}(K_q,K_p)} \ell_{K_p}(q)$
% where $M_{n+1}$ = billiard trajectories with $\le n+1$ bouncing points.
%
% COMPLEXITY MOTIVATION:
%   - HK2017: $O(F!)$ where $F$ = facet count
%   - Billiard algorithm: $O((E_q + E_p)^6)$ where $E$ = edge counts
%   - Polynomial vs factorial is a major improvement for Lagrangian products
%
% -----------------------------------------------------------------------------
% STRUCTURE OF A 3-BOUNCE ORBIT
% -----------------------------------------------------------------------------
%
% A 3-bounce orbit has 6 breakpoints alternating constant-$q$ and constant-$p$:
%   $(q_1,p_1) \to (q_1,p_2) \to (q_2,p_2) \to (q_2,p_3) \to (q_3,p_3) \to (q_3,p_1) \to (q_1,p_1)$
%
% Variables: 3 points $q_1,q_2,q_3 \in \partial K_q$ and 3 points $p_1,p_2,p_3 \in \partial K_p$.
% Each point is (edge index, position on edge $\in [0,1)$).
%
% -----------------------------------------------------------------------------
% REFLECTION RULE AND CONSTRAINTS
% -----------------------------------------------------------------------------
%
% Rudolf's reflection rule $q_{j+1} - q_j \in N_{K_p}(p_j)$ is equivalent to
% the differential inclusion for Reeb orbits (no new theory needed).
%
% For polygons:
%   - If $p_j$ is on edge interior: $N_{K_p}(p_j) = \R_+ \cdot n_e$ (1D, single normal)
%     Constraint: $q_{j+1} - q_j = t \cdot \frac{2}{h} n_e$ with $t \ge 0$ (equality + sign)
%
%   - If $p_j$ is a vertex (intersection of edges $L,R$):
%     $N_{K_p}(p_j) = \R_+ \cdot \conv\{n_L, n_R\}$ (2D cone)
%     Constraint: $q_{j+1} - q_j = t_L \cdot \frac{2}{h_L} n_L + t_R \cdot \frac{2}{h_R} n_R$
%     with $t_L, t_R \ge 0$ (inequalities)
%
% OBJECTIVE: Minimize action $= \sum (t_L + t_R + \ldots)$ = sum of Reeb coefficients.
% This is the period of the orbit ($\alpha(R) = 1$ by Reeb normalization).
%
% RESULT: Linear programming problem per combinatorial configuration!
%
% -----------------------------------------------------------------------------
% ALGORITHM OUTLINE
% -----------------------------------------------------------------------------
%
% 1. COMBINATORIAL OUTER LOOP: For each configuration
%    - Which edge of $K_q$ does each $q_i$ lie on? $\to E_q^3$ choices
%    - Which edge of $K_p$ does each $p_i$ lie on? $\to E_p^3$ choices
%    - For each of 6 points: vertex or edge-interior? $\to 2^6$ sub-choices
%
% 2. LP INNER PROBLEM: For each configuration, solve:
%    - Variables: 6 edge-position parameters + time coefficients $(t_L, t_R)$ per transition
%    - Constraints: reflection rules as linear (in)equalities, $t \ge 0$
%    - Objective: minimize $\sum t_i$ = action
%
% 3. RETURN: Global minimum action and corresponding orbit
%
% -----------------------------------------------------------------------------
% UNIFORM LP FORMULATION (to avoid heterogeneous constraint structures)
% -----------------------------------------------------------------------------
%
% Always use $(t_L, t_R)$ per transition, even for edge-interior points:
%   - For edge-interior: add constraint $t_L = 0$ (or $t_R = 0$), using only true normal
%   - For vertex: both $t_L, t_R$ free
%
% This gives fixed variable count (18 = 6 positions + 12 times) with uniform
% constraint matrix structure. Only which $t_L = 0$ constraints are active varies.
%
% The "fake edge" framing: pretend there are always 2 adjacent edges at each
% bounce point, but one has zero time allocation for edge-interior points.
%
% -----------------------------------------------------------------------------
% OPEN QUESTIONS
% -----------------------------------------------------------------------------
%
% 1. Can we prove minimum-action orbit always has bounces at vertices (not
%    edge-interiors)? This would eliminate the $2^6$ factor.
%
% 2. Exact LP constraint structure for closure and geometric compatibility.
%
% 3. 2-bounce orbits: simpler (4 breakpoints, 2 $q$-values, 2 $p$-values).
%
% 4. Numerical considerations: LP solver choice, tolerances, degeneracies.
%
% =============================================================================
% END DESIGN NOTES
% =============================================================================

% TODO: Write up formal algorithm based on above design notes.

\section{Algorithm Developed in This Thesis}\label{sec:algo-ours}

Our algorithm extends the CH2021 algorithm to cover all edge cases and to achieve sufficient numerical stability and performance to investigate some polytope families of interest for Viterbo's conjecture.
We describe our algorithm in detail, without requiring the reader to be familiar with the algorithms of CH2021 or HK2017.

We start by focusing on the case of a search over orbits that do not involve any lagrangian 2-faces, e.g. because the polytope contains no lagrangian 2-faces, which is only slightly more general than in CH2021. We afterwards cover the second case of a search over orbits that do involve at least one lagrangian 2-face, which is new compared to CH2021, and together gives us full generality.

\subsection{Case: Orbits Without Lagrangian 2-Faces}
Let \(K \subset \R^4\) be a convex polytope.
Let \((F_i)_{i=1}^F\) be the set of facets of \(K\). The number of facets is \(F \ge 5\).

\begin{definition}[2-Face]
  An intersection \(F_i \cap F_j\) of two facets \(F_i, F_j\) is called a 2-face of \(K\) if it has non-empty interior.
  So we exclude degenerate intersections that are 1-faces or 0-faces.
  It is called lagrangian, iff its tangent space is a lagrangian subspace of \(\R^4\) wrt the standard symplectic form, i.e. iff \(\omega|_{F_i \cap F_j} \equiv 0\).
\end{definition}

We want to calculate a modified version of \(\cEHZ(K)\) by searching for the minimum action over all closed Reeb orbits on \(\partial K\) that do not cross or flow along any lagrangian 2-faces.
For simplicity, one can imagine a polytope without any lagrangian 2-faces, in which case all closed Reeb orbits are considered, and we compute the actual \(\cEHZ(K)\).
By \todoref{thm:simple-min-action-reeb-orbit} and \todoref{thm:cz-index} we know that it is enough to consider those Reeb orbits that are simple polygonal, and have combinatorial rotation number \(\rho \le 2\) in the sense of Chaidez--Hutchings \cite{CH2021} (measured in turns, i.e. \(1 = 2\pi\)). In particular, we can ignore Reeb orbits that flow along 1-faces as they have rotation \(\rho = +\infty\).

We will see that we can group these orbits (redundantly) into combinatorial classes. Our algorithm then searches over all combinatorial classes, and all orbits in each class, to find the minimum action closed Reeb orbit.
We can expand the definition to also classify non-closed finite-length trajectories. This then gives the combinatorial classes a tree structure, and we can do a more efficient branch-and-bound search over the tree.

\begin{definition}
  Let \(\gamma: [0,T] \to \partial K\) be a Reeb trajectory of finite length \(T > 0\).
  Let the trajectory be polygonal with break times \((t_k)_{k=1}^{m+1}\) and break points \(\gamma(t_k) = b_k\).
  Let the trajectory flow never along a 1-face or a lagrangian 2-face of \(K\) and never cross a lagrangian 2-face.
  As a consequence, the segments \(\gamma|_{(t_k, t_{k+1})}\) all lie in the interior of a facet \(F_{i_k}\), with associated Reeb vector as velocity.
  The inner break points lie on the intersection of two facets, but that needn't be a 2-face, since the intersection can be degenerate (e.g. a 1-face or 0-face).
  We can in this case however insert (non-uniquely determined) indices with zero-duration segments and additional break points to ensure that all facet changes happen on 2-faces.
  Let the trajectory further be maximal, i.e. it cannot be extended further without introducing a new inner break point. Then it must start and end on the boundary of \(F_1\) and \(F_m\) respectively.
  We can introduce a (not necessarily unique) index \(i_0\) such that the \(F_{i_0} \cap F_{i_1}\) is a 2-face, and the break point \(b_1\) lies on the closed 2-face (not necessarily in the interior).
  Similarly define an index \(i_{m+1}\) for the end break point \(b_{m+1}\).
  All in all we now have a sequence \((i_0, i_1, \ldots, i_m, i_{m+1})\), such that the trajectory \(\gamma\) starts on the closed 2-face \(F_{i_0} \cap F_{i_1}\), flows through the facets \(F_{i_1}, \ldots, F_{i_m}\) crossing the 2-faces \(F_{i_k} \cap F_{i_{k+1}}\) for \(k=1, \ldots, m-1\), and ends on the closed 2-face \(F_{i_m} \cap F_{i_{m+1}}\).
  We then say that \(\gamma\) is of combinatorial class \((i_0, i_1, \ldots, i_m, i_{m+1})\).
  Note that \(\gamma\) may belong to multiple combinatorial classes, since we may have multiple choices for the zero-duration segments we insert or prepend/append.
\end{definition}

\begin{definition}
  Let \(i_0, \ldots, i_{m+1}\) be a sequence of facet indices.
  We then call the set of all Reeb trajectories of combinatorial class \((i_0, \ldots, i_m, i_{m+1})\) the tubular trajectory set (short: tube) of the class.
\end{definition}

\begin{lemma}
  It's easy to see that in order to be the class of any trajectory, the sequence must satisfy the following necessary but not sufficient adjacency conditions:
  \begin{itemize}
    \item For all \(k=0, \ldots, m\), the intersection \(F_{i_k} \cap F_{i_{k+1}}\) is a 2-face of \(K\), i.e. has non-empty interior and is non-lagrangian.
    \item For all \(k=0, \ldots, m\), the Reeb flow crosses the 2-face \(F_{i_k} \cap F_{i_{k+1}}\) from facet \(F_{i_k}\) into facet \(F_{i_{k+1}}\).
  \end{itemize}
  Furthermore, if we only look for simple closed Reeb orbits, then it is sufficient to look at sequences with
  \begin{itemize}
    \item All indices \(i_k\) are distinct, except optionally \(i_0 = i_{m}\) and/or \(i_{1} = i_{m+1}\) if the trajectory starts and ends on the same 2-face.
  \end{itemize}

  We can enumerate the facet index sequences satisfying these three conditions by building a search tree (or rather, a forest) as follows:
  \begin{itemize}
    \item The root nodes are all 2-faces \((i_0, i_1)\). These are called \emph{initial tubes}.
    \item We go from a node \(i_0, \ldots, i_k\) to a node \(i_0, \ldots, i_k, i_{k+1}\) if the sequence satisfies still the adjacency conditions and simplicity condition.
    \item A tube is \emph{next-step closeable} if \(i_0 = i_k\) (first facet equals last facet). Extending such a tube by \(i_1\) yields a closed tube.
    \item A tube is \emph{closed} if \(i_{k-1} = i_0\) and \(i_k = i_1\), i.e., the sequence ends with the same two facets it started with. Equivalently, the start 2-face equals the end 2-face. We mark closed nodes for searching since they cover all simple closed Reeb orbits.
    \item We drop leaf nodes that cannot lead to closed tubes, i.e. where no next facet can be picked without violating the adjacency or simplicity conditions, and the sequence is not yet closed.
  \end{itemize}

  Every closed tube is the one-step extension of a unique next-step closeable tube. Closed tubes have minimum length 5 (corresponding to 3 distinct facets), because flow direction antisymmetry prevents returning to the entry facet after a single transition.
\end{lemma}

There are three useful pruning lemmas that allow us to skip large parts of the tree during the search for minimum action closed Reeb orbits.

\begin{lemma}[Pruning]
  Consider the tube at node \(i_0, \ldots, i_k\).
  The following properties now hold for the entire subtree rooted at that node, if they hold for the node already:
  \begin{itemize}
    \item If the tube is empty, then all tubes in the subtree rooted at that node are empty as well.
    \item If the tube has rotation \(\rho > 2\), then all tubes in the subtree rooted at that node have rotation \(> 2\) as well.
    \item If the tube has minimum action \(> c\), then all tubes in the subtree rooted at that node have minimum action \(> c\) as well.
  \end{itemize}

  The main argument for all three cases is that the trajectory in a child tube restricts to a trajectory in the parent tube, and that rotation and action are monotone under restriction.
\end{lemma}

Of course, we need to be able to compute the tubes, their emptiness, rotation, and minimum action efficiently.
We again use how the child tube has trajectories that restrict to trajectories in the parent tube, and derive an iterative computation scheme.

\begin{theorem}[Iterative Tube Data Computation]
  Consider the tube at node \(i_0, \ldots, i_k\).
  We attach the following data to the tube, and assume it is computed already:
  \begin{description}
    \item[Set of start and endpoints] Let \(P_{start} \subset F_{i_0} \cap F_{i_1}\) be the closed convex polygon of all possible start points of the trajectories, and let \(P_{end} \subset F_{i_k} \cap F_{i_{k+1}}\) be the closed convex polygon of all possible endpoints of the trajectories.
    \item[Action] Let \(A: P_{end} \to \R_{\ge 0}\) be the action of the trajectories as a function on the endpoints.
    \item[Rotation] Let \(\rho \in \R_{\ge 0}\) be the combinatorial rotation number of the trajectories in the sense of Chaidez--Hutchings \cite{CH2021}, measured in turns (i.e. \(1 = 2\pi\)). See Section~\ref{sec:rotation-number} for the precise definition.
    \item[Flow map] Let \(\psi: P_{start} \cong P_{end}\) be the flow map that maps any start point to the corresponding endpoint of the trajectory. The linear part of this affine map is computed using transition matrices (Section~\ref{sec:transition-matrix}).
  \end{description}
  We used in the definition above that the flow map is a composition of affine maps, and thus itself affine. The composed functions come from the Reeb flow on each facet, which affinely maps points from one 2-face to the next, as long as the trajectory of course crosses both closed 2-faces.
  The action increments equal the time increments, which are also affine. The added action is thus affine in the start or end point.
  The rotation increments occur at the inner break points, and so are constant wrt which trajectory in the tube we pick.

  Above considerations directly tell us how to compute the tube data at node \(i_0, \ldots, i_{k+1}\) from the tube data at node \(i_0, \ldots, i_k\).
  We only need the affine maps
  \begin{align*}
    \phi: \mathrm{affine}(F_{i_k} \cap F_{i_{k+1}}) \to \mathrm{affine}(F_{i_{k+1}} \cap F_{i_{k+2}}) \\
    A_{inc}: \mathrm{affine}(F_{i_k} \cap F_{i_{k+1}}) \to \R_{\ge 0} \\
  \end{align*}
  describing the flow along the facet \(F_{i_{k+1}}\), namely the map between 2-faces, and the associated duration/action increment. And the rotation increment at the new break point (see Section~\ref{sec:rotation-number} for the formula):
  \[
    \rho(F_{i_k} \cap F_{i_{k+1}}) = \frac{1}{2\pi} \arccos\bigl(\inner{n_{i_k}}{n_{i_{k+1}}}\bigr).
  \]
  Then:
  \begin{align*}
    P_{end}^\prime & = \phi(P_{end}) \cap (F_{i_{k+1}} \cap F_{i_{k+2}}) \\
    A^\prime(z) & = (A + A_{inc})(\phi^{-1}(z)) \\
    \rho^\prime & = \rho + \rho(F_{i_k} \cap F_{i_{k+1}}) \\
    \psi^\prime(z) & = \phi(\psi(z))
  \end{align*}
\end{theorem}

Note: In the final implementation, we slightly change the data definitions to increase performance further by a constant factor, but the above is conceptually cleaner.

As a start, we briefly state the tube data at the root nodes.
\begin{lemma}[Root Tube Data]
  Consider the root node \(i_0, i_1\) corresponding to a 2-face \(F_{i_0} \cap F_{i_1}\).
  The tube at that node consists of all zero-length \(T=0\) trajectories on the 2-face.
  Thus, the set of start and endpoints is the entire closed 2-face:
  \[
    P_{start} = P_{end} = F_{i_0} \cap F_{i_1}.
  \]
  The action is zero everywhere:
  \[
    A = 0.
  \]
  There are no inner break points, so the rotation is
  \[
    \rho = 0.
  \]
  The flow map is the identity:
  \[
    \psi = \Id.
  \]  
\end{lemma}

As an end, we now need to look in the closeable tubes for minimum action closed Reeb orbits.
\begin{definition}[Closing a Closeable Tube]
  Consider a closeable tube at node \(i_0, \ldots, i_m = i_0, i_{m+1} = i_1\).
  We want to find closed Reeb orbits in the tube, i.e. trajectories that start and end at the same point, not just the same 2-face.
  For this we can use the flow map \(\psi: P_{start} \cong P_{end}\).
  We look for fixed points of the flow map, i.e. points \(z \in F_{i_0} \cap F_{i_1} = F_{i_m} \cap F_{i_{m+1}}\) with \(\psi(z) = z\).
  In an unconstrained affine subspace setting, an affine map has no, one, a line, or a plane of fixed points.
  Here, we have the additional constraint that the fixed points must lie in the polygon \(P_{end}\), as otherwise it corresponds to no trajectory in the tube.
  The result is thus again a polytope (possibly empty, possibly degenerate) of closed Reeb orbit endpoints.
  Calculating the local minimum action is straightforward, we minimize an affine function over a convex polygon.
\end{definition}

We can now present the full branch-and-bound algorithm to compute \(\cEHZ(K)\).

\begin{theorem}[Branch-and-Bound Capacity Algorithm]
  Let \(K \subset \R^4\) be a convex polytope. We want to compute \(\cEHZ(K)\), either assuming \(K\) has no lagrangian 2-faces, or calculating only the upper bound that comes from going over the Reeb orbits that do not cross or flow along lagrangian 2-faces.
  Either way, in the following we ignore all trajectories and classes that involve lagrangian 2-faces.

  We start by initializing a global variable with an upper bound on \(\cEHZ(K)\), e.g. from an enclosing ellipsoid.

  We can walk the previously defined tree of combinatorial classes in a depth-first manner.
  We update the upper bound global variable whenever we encounter a closeable tube with a closed Reeb orbit of lower action than the current upper bound.
  The depth-first approach allows us to use iterative tube data computation and pruning of subtrees.

  In the end, regardless of traversal order, or whether we are strictly depth-first or use other heuristics, the global upper bound variable will have reached \(\cEHZ(K)\) and is returned as the result.
\end{theorem}

One major difficulty is of course coming up with heuristics for the traversal order that lead to fast convergence of the upper bound variable to \(\cEHZ(K)\), and thus fast pruning of the remaining tree.
We have experimented with several heuristics:

\begin{itemize}
  \item Outer loop over root nodes, then skip already fully explored 2-faces in later subtrees. This is equivalent to deleting/outlawing the 2-face from the polytope, which is fine since all trajectories going through it are already explored.
  \item Use graph shortest cycle search, i.e. find closeable tubes with few inner break points, and explore those first.
  \item Use a different algorithm to guess a tighter upper bound on \(\cEHZ(K)\), e.g. monte carlo sampling of trajectories.
  \item Randomize to reduce correlation in exploration, s.t. the upper bound vs time curve initially drops faster, and is in total shorter bc we can prune more subtrees earlier.
  \item Use a weighted graph cycle search, where the weights guesstimate the average/minimum action of trajectories going along a facet.
\end{itemize}

We assess the experimented heuristics by plotting the upper bound vs number of closeable tubes explored / vs wall time, and by looking at the total time taken to return the verified result.

\subsection{Case: Polytopes With Lagrangian 2-Faces}

Previously we excluded polytopes with lagrangian 2-faces, or rather, we excluded orbits that cross or flow along lagrangian 2-faces.
We can now present a fallback algorithm that explores all Reeb orbits that do cross or flow along lagrangian 2-faces, to get an upper bound on \(\cEHZ(K)\) in that case as well.
The true minimum action capacity is then the minimum of the two cases.

Let \(K \subset \R^4\) be a convex polytope with at least one lagrangian 2-face.
Let \((F_i)_{i=1}^F\) be the set of facets of \(K\). The number of facets is \(F \ge 5\).

Just like before, we can define combinatorial classes of Reeb trajectories.

\begin{definition}
  Let \(\gamma: [0,T] \to \partial K\) be a Reeb trajectory of finite length \(T > 0\).
  Let the trajectory be polygonal with break times \((t_k)_{k=1}^{m+1}\) and break points \(\gamma(t_k) = b_k\).
  Let the trajectory flow never along a 1-face of \(K\).
  Let the trajectory description include zero-length segments at break points as needed, such that all \(F_{i_k} \cap F_{i_{k+1}}\) are 2-faces, for \(k=0, \ldots, m\).
  Let the trajectory be maximal: it cannot be extended further without introducing a new inner break point where the velocity changes. Then it must start and end on \(F_0 \cap F_1\) and \(F_m \cap F_{m+1}\) respectively. Note that we slightly use a trick here, since for lagrangian 2-faces two possible Reeb velocities exist. We can ensure a point \(b_1\) on a lagrangian 2-face stays the start point of the \(F_{i_1}\) velocity segment by picking a zero-duration segment with velocity from \(F_{i_0}\), s.t. extending backwards only happens with the other velocity.
  As a result, we can further assume that the trajectory starts on the boundary of a lagrangian 2-face, i.e. a 1-face or 0-face.
  We do not have the guarantee that the segments \(\gamma|_{(t_k, t_{k+1})}\) all lie in the interior of a facet \(F_{i_k}\), since they may instead lie on the interior of a lagrangian 2-face.
  The break points need not signify a change in face, since break points can lie on the interior of 2-faces.

  We can still define the combinatorial class \((i_0, i_1, \ldots, i_m, i_{m+1})\) of the trajectory \(\gamma\) as before, and just have to keep track of the degrees of freedom due to interior breakpoints inside lagrangian 2-faces when we compute the tubes.

  We have that \(\gamma\) starts on the boundary of a lagrangian 2-face, i.e. on some closed 1-face given by \(F_{i_0} \cap F_{i_1} \cap F_{i_2}\), then flows potentially with zero duration along \(F_{i_1}\) and then a finite duration along \(F_{i_2}\), before reaching the next 1-face \(F_{i_1} \cap F_{i_2} \cap F_{i_3}\), from where it may enter the interior of a 3-face, cross through zero duration non-lagrangian 2-faces, or flow along another lagrangian 2-face. No statement is made about the end-point, i.e. it may lie in the interior of a lagrangian 2-face or a crossing point on a closed non-lagrangian 2-face.
\end{definition}

\begin{definition}
  Let \(i_0, \ldots, i_{m+1}\) be a sequence of facet indices. As before we require the same adjacency conditions to hold.
  \begin{itemize}
    \item For all \(k=0, \ldots, m\), the intersection \(F_{i_k} \cap F_{i_{k+1}}\) is a 2-face of \(K\), i.e. has non-empty interior.
    \item For all \(k=0, \ldots, m\), either the Reeb flow crosses the non-lagrangian 2-face \(F_{i_k} \cap F_{i_{k+1}}\) from facet \(F_{i_k}\) into facet \(F_{i_{k+1}}\), or the 2-face is lagrangian in which case no unique order of facets exists.
    \item If we only look for simple closed Reeb orbits, then all indices \(i_k\) are distinct, except optionally \(i_0 = i_{m}\) and/or \(i_{1} = i_{m+1}\) if the trajectory starts and ends on the same 2-face.
  \end{itemize}

  We can enumerate the facet index sequences satisfying these three conditions by building a search tree (or rather, a forest) as follows:
  \begin{itemize}
    \item The root node is a 1-face of the chosen lagrangian 2-face, i.e. \((i_0, i_1, i_2)\) where \(F_{i_1} \cap F_{i_2}\) is the chosen lagrangian 2-face.
    \item We go from a node \(i_0, \ldots, i_k\) to a node \(i_0, \ldots, i_k, i_{k+1}\) if the sequence satisfies still the adjacency conditions and simplicity condition.
    \item We mark nodes of the form \(i_0, i_1, \ldots, i_m = i_0, i_{m+1} = i_1\) as ``closeable'', since searching them covers the search over all simple closed Reeb orbits.
    \item We drop leaf nodes that are not closeable, i.e. where no next facet and implied 2-face can be picked without violating the adjacency or simplicity conditions, and yet the sequence didn't end on the 2-face it started on.
  \end{itemize}
\end{definition}

TODO:
\begin{itemize}
  \item Potentially the algorithm I planned performs worse than just introducing a small perturbation to make the polytope generic, especially if we are careful about how we then pick basis representations of the 2-faces to avoid numeric instability.
  \item I decided to stop here, and write up the rest (defining and enumerating parameterized tubes) later if it turns out to be actually useful/numerically stable.
\end{itemize}


\section{Numerical Considerations}\label{sec:algo-numerics}

TODO:
\begin{itemize}
  \item Instead of a theoretical start, we should begin with empirical analysis here, e.g. show concrete examples and exact moments where our algorithms fail numerically, and then build up / motivate from there an analysis of how to fix these issues.
  \item Main fixes: soft cutoffs and control flow. We'd rather overestimate the tube endpoint set, allow extra classes, and have tolerances in the rotation and action cutoffs (though only in the action cutoff if we want to enumerate all simple polygonal Reeb orbits with bounded rotation).
  \item Main case: lagrangian 2-faces are most problematic, as are nearly-lagrangian 2-faces, as are near-degeneracies e.g. relatively tiny facets, or facets with low or large angles between them.
\end{itemize}

\section{Performance and Output Metrics}\label{sec:algo-metrics}

TODO
\begin{itemize}
  \item Run and write up benchmarks for the different algorithms (HK2017, CH2021, ours), on a common set of polytopes.
  \item Profile our algorithm, and justify the effort we put into optimizing only some hotspots.
  \item Ablate different features/implementation choices and compare performance to measure impact of our work.
  \item Maybe compare to a OG python implementation as well, or to matlab code if we get it working, to show the performance gain of picking a professional software development approach.
\end{itemize}

\section{Data Science Pipeline}\label{sec:algo-datapipeline}

Based on the algorithms we implemented, we want to probe Viterbo's conjecture using the tool box of a data scientist.
Basically, we throw lots of standard techniques at the problem, and see what sticks.
This kind of approach has become feasable due to the capabilities of modern AI agents, which can near-autonomously carry out simple standard data science tasks, freeing up human time to inspect the results the ai agents prepares and hands back.

The main ingredients we set up by hand to faciliate an environment where ai agents can work effectively are:
\begin{itemize}
  \item A high performance rust library for symplectic geometry on polytopes, including systolic ratio computation, and including random sampling or enumeration of polytope families of interest.
  \item A large dataset of polytopes of interest, including computed systolic ratios and other data about single polytopes.
  \item A standard scaffolding in Python, for isolated data science experiments that mostly are independent of each other, or have explicit dependencies on each other's artifacts.
  \item Proper development practices and tools for data provisioning, i.e. tracking our experiments in detail, and for reproducibility, i.e. all our data can be rederived from scratch using e.g. deterministic pseudorandom generators (though as usual, we cannot exclude changes in behavior due to machine architecture or software stack changes beyond our control).
\end{itemize}

\section{Summary}\label{sec:algo-summary}
We presented in detail our algorithm for computing \(\cEHZ(K)\) of a convex polytope \(K \subset \R^4\), extending the CH2021 algorithm to full generality and improving numerical stability and performance sufficiently to investigate some polytope families of interest for Viterbo's conjecture using massive data science techniques, rather than low-throughput manual case-by-case analysis.
We further gave an overview of the other algorithms from the literature we implemented, and of the main symplectic geometry subroutines we used as building blocks.

The results from running data science experiments based on this symplectic geometry library and basic scaffolding are presented in chapter \ref{chap:experiments}.
